// https://school.programmers.co.kr/learn/courses/30/lessons/12980
// 10 start


import java.util.*;

public class Solution {
    public int solution(int n) {
        int ans = 0;

        // K칸 앞으로 이동 or 현재 거리 *2 이동 (순간이동) 가능
        // 순간이동은 에너지 사용X, K칸 앞으로는 K만큼 에너지 사용
        // 거리가 N만큼의 거리를 이동하려 할때 최소한의 에너지를 사용하여 이동
        // 사용해야하는 건전지 사용량의 최소값은?

        // 처음 위치 0

        // 1 <= N <= 10억
        // K는 1이상의 자연수

        // 해결 방법
        // BFS로 가장 빠르게 도착하는 방식 찾기 ?

        // 처음에는 무조건 K만큼 이동
        // 후에 *2 *2

        // 2^n의 배수로 만들면 됨?

        // ex. 5
        // 5/2 = 2 , 5%2 = 1 -> +2*2 +1
        // 5/4 = 1 , 5%4 = 1 -> +1*4 +1

        // 5-1 -> 4/4

        // 6/2 = 3 , 6%2 = 0 -> +3*2 +0
        // 6/4 = 1 , 6%4 = 2 ->
        // 6/2 -> 3-1 2/2

        // 20 +1 *4 +1 *4

        // 20/4 -> 5-1 -> 4/4 -> 1

        // 2^t로 나눌수있으면 나눈다. t>=1 , 나눌수 없다면 2^t로 나눌수 있을때까지 뺸다.(짝수로 만든다.)
        // n이 1이되면 멈춘다.

        while (n > 1) {
            if (n % 2 == 0) {
                // 짝수
                while (n % 2 == 0) {
                    n = n / 2;
                }
            } else {
                n--;
                ans++;
            }

        }


        return ans+1;
    }
}
